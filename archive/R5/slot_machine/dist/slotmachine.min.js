!function(t,i){"object"==typeof exports&&"object"==typeof module?module.exports=i():"function"==typeof define&&define.amd?define("SlotMachine",[],i):"object"==typeof exports?exports.SlotMachine=i():t.SlotMachine=i()}(self,(()=>(()=>{"use strict";var t={d:(i,e)=>{for(var s in e)t.o(e,s)&&!t.o(i,s)&&Object.defineProperty(i,s,{enumerable:!0,get:e[s]})},o:(t,i)=>Object.prototype.hasOwnProperty.call(t,i)},i={};t.d(i,{default:()=>h});class e{constructor(t){this.container=t,this.tiles=[],this.tileNodes=[];const i=[].slice.call(this.container.children);this.container.style.overflow="hidden",this.element=document.createElement("div"),this.element.classList.add("slot-machine__container"),this.element.style.transition="1s ease-in-out",this.container.appendChild(this.element),this.tiles=[...i].map((t=>new s(t))),this.tileNodes=[this.tiles[this.tiles.length-1].clone(),...this.tiles,this.tiles[0].clone()],this.wrapTiles()}wrapTiles(){this.tileNodes.forEach((t=>{this.element.appendChild(t.element)}))}get lastTileOffset(){return this.tiles[0].offset}getTileOffset(t){let i=0;for(let e=0;e<t;e++)i+=this.tiles[e].offset;return-this.lastTileOffset-i}get maxTopOffset(){return-1*(this.tiles.reduce(((t,{offset:i})=>t+i),0)+this.lastTileOffset)}}class s{constructor(t){this.element=t,this.element.classList.add("slot-machine__tile")}clone(){const t=this.element.cloneNode(!0);return new s(t)}get offset(){return this.element.offsetHeight}}const n={active:0,delay:200,randomize:(t,i)=>function(t,i){return Math.floor(Math.random()*(i-t+1))+t}(0,i),direction:"up"};var o,a;!function(t){t.GRADIENT="slot-machine__container--gradient"}(o||(o={})),function(t){t.NO_TRANSITION="slot-machine__tile--no-transition",t.FAST="slot-machine__tile--blur-fast",t.NORMAL="slot-machine__tile--blur-medium",t.SLOW="slot-machine__tile--blur-slow",t.TURTLE="slot-machine__tile--blur-turtle",t.STOP="slot-machine__tile--gradient"}(a||(a={}));const r=t=>new Promise((i=>setTimeout(i,t)));class h{constructor(t,i){this.running=!1,this.stopping=!1,this.element=t,this.container=new e(this.element),this.setOptions(i),this.active=this.options.active,this.setupBounds(),this._resetPosition()}setOptions(t){this.options={...n,...t}}setupBounds(){const t=this.container.getTileOffset(this.active),i=this.container.getTileOffset(0),e=this.container.getTileOffset(this.container.tiles.length-1);this._bounds={up:{initial:t,from:e,to:0,nextReset:0,prevReset:this.container.maxTopOffset},down:{initial:t,from:i,to:this.container.maxTopOffset,nextReset:0,prevReset:this.container.maxTopOffset}}}get bounds(){return this._bounds[this.options.direction]}get active(){return this._active}set active(t){(t<0||t>=this.container.tiles.length||isNaN(t))&&(t=0),this._active=t}get transition(){return this._transition}set transition(t){this._transition=t||"ease-in-out"}get _prevIndex(){const t=this.active-1;return t<0?this.container.tiles.length-1:t}get _nextIndex(){const t=this.active+1;return t<this.container.tiles.length?t:0}get prevIndex(){return"up"===this.options.direction?this._nextIndex:this._prevIndex}get nextIndex(){return"up"===this.options.direction?this._prevIndex:this._nextIndex}set _animationFX(t){!function(t,i=0){setTimeout((()=>requestAnimationFrame(t)),i)}((()=>{this.container.tiles.map((({element:t})=>t)).forEach((i=>{i.classList.remove(a.FAST,a.NORMAL,a.SLOW,a.TURTLE),t!==a.STOP&&i.classList.add(t)})),t===a.STOP?this.container.element.classList.remove(o.GRADIENT):this.container.element.classList.add(o.GRADIENT)}),this.options.delay/4)}_changeTransition(t=this.options.delay,i=this.transition){this.container.element.style.transition=`${t/1e3}s ${i}`}_changeTransform(t){this.container.element.style.transform=`matrix(1, 0, 0, 1, 0, ${t})`}_isGoingBackward(){return!(0!==this.active||this.nextActive!==this.container.tiles.length-1)}_isGoingForward(){return!(this.active!==this.container.tiles.length-1||0!==this.nextActive)}_resetPosition(t){this.container.element.classList.toggle(a.NO_TRANSITION),this._changeTransform(void 0!==t?t:this.bounds.initial),this.container.element.offsetHeight,this.container.element.classList.toggle(a.NO_TRANSITION)}async next(){return this.nextActive=this.nextIndex,this.running=!0,await this.stop(0),this.active}async prev(){return this.nextActive=this.prevIndex,this.running=!0,await this.stop(0),this.active}_getDelayFromSpins(t){let i=this.options.delay;switch(this.transition="linear",t){case 1:i/=.5,this.transition="ease-out",this._animationFX=a.TURTLE;break;case 2:i/=.75,this._animationFX=a.SLOW;break;case 3:i/=1,this._animationFX=a.NORMAL;break;case 4:i/=1.25,this._animationFX=a.NORMAL;break;default:i/=1.5,this._animationFX=a.FAST}return i}shuffle(t){if(!this.running&&!this.stopping)return this.nextActive=this.options.randomize(this.active,this.container.tiles.length),this.remainingSpins=t,this._shuffle()}async _shuffle(){this.running=!0;const t=this._getDelayFromSpins(this.remainingSpins);this._changeTransition(t),this._changeTransform(this.bounds.to),await r(t),!this.stopping&&this.running&&(this.remainingSpins--,this._resetPosition(this.bounds.from),this.remainingSpins>1?await this._shuffle():await this.stop(0))}async stop(t=0){if(!this.running||this.stopping)return this.nextActive;if(this.running&&!this.stopping&&t)return void(this.remainingSpins=t);this.running=!0,this.stopping=!0,this._isGoingBackward()?this._resetPosition(this.bounds.prevReset):this._isGoingForward()&&this._resetPosition(this.bounds.nextReset),this.active=this.nextActive;const i=this._getDelayFromSpins(1);this._changeTransition(i),this._animationFX=a.STOP,this._changeTransform(this.container.getTileOffset(this.active)),await r(i),this.stopping=!1,this.running=!1,this.nextActive=void 0}}return i=i.default})()));
//# sourceMappingURL=slotmachine.min.js.map