{"version":3,"file":"slotmachine.min.js","mappings":"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","sources":["webpack://SlotMachine/webpack/universalModuleDefinition","webpack://SlotMachine/webpack/bootstrap","webpack://SlotMachine/webpack/runtime/define property getters","webpack://SlotMachine/webpack/runtime/hasOwnProperty shorthand","webpack://SlotMachine/./lib/dom.ts","webpack://SlotMachine/./lib/constants.ts","webpack://SlotMachine/./lib/index.ts","webpack://SlotMachine/./lib/raf.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SlotMachine\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SlotMachine\"] = factory();\n\telse\n\t\troot[\"SlotMachine\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export class Container {\n  element: HTMLElement;\n  tiles: Tile[] = [];\n  tileNodes: Tile[] = [];\n\n  constructor(public container: HTMLElement) {\n    const tileElements = [].slice.call(this.container.children) as HTMLElement[];\n\n    this.container.style.overflow = 'hidden';\n    this.element = document.createElement('div');\n    this.element.classList.add('slot-machine__container');\n    this.element.style.transition = '1s ease-in-out';\n    this.container.appendChild(this.element);\n    this.tiles = [...tileElements].map((element) => new Tile(element));\n    this.tileNodes = [\n      this.tiles[this.tiles.length - 1].clone(),\n      ...this.tiles,\n      this.tiles[0].clone(),\n    ];\n    this.wrapTiles();\n  }\n\n  private wrapTiles() {\n    this.tileNodes.forEach((tile) => {\n      this.element.appendChild(tile.element);\n    });\n  }\n\n  private get lastTileOffset() {\n    return this.tiles[0].offset;\n  }\n\n  getTileOffset(index: number) {\n    let offset = 0;\n\n    for (let i = 0; i < index; i++) {\n      offset += this.tiles[i].offset;\n    }\n\n    return -this.lastTileOffset - offset;\n  }\n\n  get maxTopOffset() {\n    return -1 * (this.tiles.reduce((acc, { offset }) => acc + offset, 0) + this.lastTileOffset);\n  }\n}\n\nexport class Tile {\n  constructor(public element: HTMLElement) {\n    this.element.classList.add('slot-machine__tile');\n  }\n\n  clone() {\n    const element = this.element.cloneNode(true) as HTMLElement;\n\n    return new Tile(element);\n  }\n\n  get offset() {\n    return this.element.offsetHeight;\n  }\n}\n","import { Options } from './types';\n\nfunction randomInteger(min: number, max: number) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nexport const DEFAULTS: Required<Options> = {\n  active: 0, // Active element [Number]\n  delay: 200, // Animation time [Number]\n  randomize: (_, max) => randomInteger(0, max), // Randomize function, must return a number with the selected position\n  direction: 'up', // Animation direction ['up'||'down']\n};\n\nexport enum CONTAINER_FX {\n  GRADIENT = 'slot-machine__container--gradient',\n}\n\nexport enum TILE_FX {\n  NO_TRANSITION = 'slot-machine__tile--no-transition',\n  FAST = 'slot-machine__tile--blur-fast',\n  NORMAL = 'slot-machine__tile--blur-medium',\n  SLOW = 'slot-machine__tile--blur-slow',\n  TURTLE = 'slot-machine__tile--blur-turtle',\n  STOP = 'slot-machine__tile--gradient',\n}\n","import raf from './raf';\nimport { Container } from './dom';\nimport type { Bounds, Options } from './types';\nimport { DEFAULTS, TILE_FX, CONTAINER_FX } from './constants';\n\nconst timeout = (delay: number) => new Promise((res) => setTimeout(res, delay));\n\nexport default class SlotMachine {\n  container: Container;\n  element: HTMLElement;\n  running = false;\n  stopping = false;\n  nextActive?: number;\n\n  private remainingSpins: number;\n  private options: Required<Options>;\n  private _active: number;\n  private _bounds: Bounds;\n  private _transition: string;\n\n  constructor(element: HTMLElement, options: Options) {\n    this.element = element;\n    // Setup DOM\n    this.container = new Container(this.element);\n    // Set plugin options\n    this.setOptions(options);\n    this.active = this.options.active;\n    this.setupBounds();\n    // Show active element\n    this._resetPosition();\n  }\n\n  setOptions(options: Options) {\n    this.options = { ...DEFAULTS, ...options };\n  }\n\n  private setupBounds() {\n    const initial = this.container.getTileOffset(this.active);\n    const first = this.container.getTileOffset(0);\n    const last = this.container.getTileOffset(this.container.tiles.length - 1);\n\n    this._bounds = {\n      up: {\n        initial,\n        from: last,\n        to: 0,\n        nextReset: 0,\n        prevReset: this.container.maxTopOffset,\n      },\n      down: {\n        initial,\n        from: first,\n        to: this.container.maxTopOffset,\n        nextReset: 0,\n        prevReset: this.container.maxTopOffset,\n      },\n    };\n  }\n\n  get bounds() {\n    return this._bounds[this.options.direction];\n  }\n\n  get active() {\n    return this._active;\n  }\n\n  set active(index: number) {\n    if (index < 0 || index >= this.container.tiles.length || isNaN(index)) {\n      index = 0;\n    }\n\n    this._active = index;\n  }\n\n  private get transition() {\n    return this._transition;\n  }\n\n  private set transition(transition: string) {\n    this._transition = transition || 'ease-in-out';\n  }\n\n  get _prevIndex() {\n    const prevIndex = this.active - 1;\n\n    return prevIndex < 0 ? this.container.tiles.length - 1 : prevIndex;\n  }\n\n  get _nextIndex() {\n    const nextIndex = this.active + 1;\n\n    return nextIndex < this.container.tiles.length ? nextIndex : 0;\n  }\n\n  get prevIndex() {\n    return this.options.direction === 'up' ? this._nextIndex : this._prevIndex;\n  }\n\n  get nextIndex() {\n    return this.options.direction === 'up' ? this._prevIndex : this._nextIndex;\n  }\n\n  set _animationFX(effect: TILE_FX) {\n    const delay = this.options.delay / 4;\n\n    raf(() => {\n      this.container.tiles\n        .map(({ element }) => element)\n        .forEach((tile) => {\n          tile.classList.remove(TILE_FX.FAST, TILE_FX.NORMAL, TILE_FX.SLOW, TILE_FX.TURTLE);\n          if (effect !== TILE_FX.STOP) {\n            tile.classList.add(effect);\n          }\n        });\n\n      if (effect === TILE_FX.STOP) {\n        this.container.element.classList.remove(CONTAINER_FX.GRADIENT);\n      } else {\n        this.container.element.classList.add(CONTAINER_FX.GRADIENT);\n      }\n    }, delay);\n  }\n\n  _changeTransition(delay = this.options.delay, transition = this.transition) {\n    this.container.element.style.transition = `${delay / 1000}s ${transition}`;\n  }\n\n  _changeTransform(margin: number) {\n    this.container.element.style.transform = `matrix(1, 0, 0, 1, 0, ${margin})`;\n  }\n\n  _isGoingBackward() {\n    return !!(this.active === 0 && this.nextActive === this.container.tiles.length - 1);\n  }\n\n  _isGoingForward() {\n    return !!(this.active === this.container.tiles.length - 1 && this.nextActive === 0);\n  }\n\n  _resetPosition(margin?: number) {\n    this.container.element.classList.toggle(TILE_FX.NO_TRANSITION);\n    this._changeTransform(margin !== undefined ? margin : this.bounds.initial);\n    // Force reflow, flushing the CSS changes\n    this.container.element.offsetHeight;\n    this.container.element.classList.toggle(TILE_FX.NO_TRANSITION);\n  }\n\n  async next() {\n    this.nextActive = this.nextIndex;\n    this.running = true;\n    await this.stop(0);\n\n    return this.active;\n  }\n\n  async prev() {\n    this.nextActive = this.prevIndex;\n    this.running = true;\n    await this.stop(0);\n\n    return this.active;\n  }\n\n  _getDelayFromSpins(spins: number) {\n    let delay = this.options.delay;\n    this.transition = 'linear';\n\n    switch (spins) {\n      case 1:\n        delay /= 0.5;\n        this.transition = 'ease-out';\n        this._animationFX = TILE_FX.TURTLE;\n        break;\n      case 2:\n        delay /= 0.75;\n        this._animationFX = TILE_FX.SLOW;\n        break;\n      case 3:\n        delay /= 1;\n        this._animationFX = TILE_FX.NORMAL;\n        break;\n      case 4:\n        delay /= 1.25;\n        this._animationFX = TILE_FX.NORMAL;\n        break;\n      default:\n        delay /= 1.5;\n        this._animationFX = TILE_FX.FAST;\n    }\n\n    return delay;\n  }\n\n  shuffle(spins: number) {\n    if (this.running || this.stopping) {\n      return;\n    }\n\n    this.nextActive = this.options.randomize(this.active, this.container.tiles.length);\n    this.remainingSpins = spins;\n\n    return this._shuffle();\n  }\n\n  private async _shuffle() {\n    this.running = true;\n    // Perform animation\n    const delay = this._getDelayFromSpins(this.remainingSpins);\n    this._changeTransition(delay);\n    this._changeTransform(this.bounds.to);\n\n    await timeout(delay);\n\n    if (!this.stopping && this.running) {\n      this.remainingSpins--;\n\n      this._resetPosition(this.bounds.from);\n\n      if (this.remainingSpins > 1) {\n        // Repeat animation\n        await this._shuffle();\n      } else {\n        await this.stop(0);\n      }\n    }\n  }\n\n  async stop(spins = 0) {\n    if (!this.running || this.stopping) {\n      return this.nextActive;\n    }\n\n    if (this.running && !this.stopping && spins) {\n      this.remainingSpins = spins;\n      return;\n    }\n\n    this.running = true;\n    this.stopping = true;\n\n    // Check direction to prevent jumping\n    if (this._isGoingBackward()) {\n      this._resetPosition(this.bounds.prevReset);\n    } else if (this._isGoingForward()) {\n      this._resetPosition(this.bounds.nextReset);\n    }\n\n    // Update last choosen element index\n    this.active = this.nextActive as number;\n\n    // Perform animation\n    const delay = this._getDelayFromSpins(1);\n    this._changeTransition(delay);\n    this._animationFX = TILE_FX.STOP;\n    this._changeTransform(this.container.getTileOffset(this.active));\n\n    await timeout(delay);\n\n    this.stopping = false;\n    this.running = false;\n    this.nextActive = undefined;\n  }\n}\n","import { Callback } from './types';\n\nexport default function raf(cb: Callback, timeout = 0) {\n  setTimeout(() => requestAnimationFrame(cb), timeout);\n}\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Container","constructor","container","tiles","tileNodes","tileElements","slice","this","children","style","overflow","element","document","createElement","classList","add","transition","appendChild","map","Tile","length","clone","wrapTiles","forEach","tile","lastTileOffset","offset","getTileOffset","index","i","maxTopOffset","reduce","acc","cloneNode","offsetHeight","DEFAULTS","active","delay","randomize","_","max","min","Math","floor","random","randomInteger","direction","CONTAINER_FX","TILE_FX","timeout","Promise","res","setTimeout","SlotMachine","options","running","stopping","setOptions","setupBounds","_resetPosition","initial","first","last","_bounds","up","from","to","nextReset","prevReset","down","bounds","_active","isNaN","_transition","_prevIndex","prevIndex","_nextIndex","nextIndex","_animationFX","effect","cb","requestAnimationFrame","raf","remove","FAST","NORMAL","SLOW","TURTLE","STOP","GRADIENT","_changeTransition","_changeTransform","margin","transform","_isGoingBackward","nextActive","_isGoingForward","toggle","NO_TRANSITION","undefined","async","stop","_getDelayFromSpins","spins","shuffle","remainingSpins","_shuffle"],"sourceRoot":""}